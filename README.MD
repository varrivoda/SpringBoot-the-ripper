# Часть 1. Настройка проекта.
Для целей доклада пишем прототип "железного банка" из "игры престолов" с помощью  спринг-бута. Пишем очень быстро,поэтому ничего лишнего: для демонстрации нам достаточно таблицы bank (id, total_amount), это сводная таблица с отделениями и остатками на счетах. При поднятии приложения создается отделение 
    insert into bank(..) values (0, 100500)
и это отделение может выдавать кредиты (TransferMoneyService), логика одобрения кредита основана на предсказаниях (PredskazService).

зависимости у автора:
	compile 'org.springframework.boot:spring-boot-starter-actuator'
	compile 'org.springframework.cloud:spring-cloud-starter-feign'
	compile 'org.springframework.boot:spring-boot-starter-data-jpa'
	compile 'org.springframework.boot:spring-boot-starter-data-rest'
	compile 'org.springframework.data:spring-data-rest-hal-browser'
	compile 'org.springframework.boot:spring-boot-starter-web'
	compile 'org.flywaydb:flyway-core'
	runtime 'com.h2database:h2'
	compileOnly 'org.springframework.boot:spring-boot-configuration-processor'
	compileOnly 'org.projectlombok:lombok'
	testCompile 'org.springframework.boot:spring-boot-starter-test' 

...чёто много их, это наверно на будущее развитие лекции.
Для начала достаточно.....(todo отрезать все лишнее)

ну и да,у менявсе на мавене


*при созлании проекта я прописывал блок dependencyManagement вручную, папка target весила 7.96кб
*тема лекции о том,как работает стартер, то есть dependencyManagement будет из стартера, то есть в Поме есть <parent...> и у нас он 

    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.1.9</version>

*после подтягиварния всего и вся из стартеров,как ни старнно размер папки target не изменился, видимо пока не сгенерирую war ничего не пойму...



# Часть2, собственно доклад.
Программисты не любят думатьо зависимостях,
откроем пом
у нашего пома есть родитель-спринг-бут
у котокорого есть родитель Спринг-бут-депенденсис
у которгого огромный блок dependencyManagement
при помощи этогоблока указываются версии
иесли мы укажем зависимость без версии,то мавен смотрит в перенте этот блок, где прописаны версии
в этом блоке проприсано около 500 зависимостей,которые согласованы друг с другом

проблема в том,что в нашей компании есть свой parent.pom, как нам быть если мы хотим использовать его.еслимы хотим исподьщлвать Спринг? множественногонаследованиея ведь нет.

Для этоговнашем блоке dependencyManagement можно прописать импорт на так наз "bom"
подробнее см доклад "Maven vs Gradle"

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>io.spring.platform</groupId>
                <artifactId>platform-bom</artifactId>
                <version>Brussels-SR2</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

это сейчас модно,писать свои Бомы, особенно в крупных компаниях

    //в Градле это делается так:
    dependencyManagement {
        imports {
            mavenBom 'org.springframework.cloud:scpring-cloud-dependencies:Daltson.RELEASE'
        }
    }

Теперь непосредственно о зависимостях конкретнонашего приложения:
допустим, нам надо чтобы оно отвечало по http, имело пожддержку БД и JPA
Раньше это было так: "мне надоработать с БД" - и начинается: transactionalManager, SpringTX, Hibernate-entityManager -core  ит.д.. Потом, "нам нужен Спринг" - значит нужет СпрингORM...

Для одной простой strob надо былодумать о 3-5 зависимостях.
Теперь за нас об этом думает Стартер.

Идея стартера такая (кроме всего прочего), что он агрегирует те зависимости, которые нужны длятого "мира",откуда он пришел. Если это Стартер-security, то мы не думаем о том, какие нужны зависимости для security, астартер уже сагрегировал всеэти зависимости. Тоже для data-jpa и всегопрочего. Таким образом,у нас Пом выглядит в 3-5 зависимости - точто нужно, плюс например база данных.

# часть 3.
Итак, у нас нет конфликта зависимостей и версий.
Следующая боль - настроить контекст.

Раншье мы прописывали в xml или java-конфигах много инфраструктурных бинов
Например для Hibernate нужен EntityManagertFactoryBean, TransactionManager, DataSource... короче кучач разных инфраструктурных бинов...и что мы раньше делали? создавали в Мейне контекст, если из XML то он был пустой. Еслимы строили из AnnotationConfigApplicationContext, то нам попадались некоторые бины,которые могли настраивать конекст согласно аннотациям....

А в мейне, который у нас сейчас?
SpringApplication.run() а где же здесь контекст? что,спринг отказался от Контекста?

первое - а зачем он нам нужен?
второе - он там есть (метод run() возвражает контекст). Но вообще-то он нам особо и не нужен.

Раньшебыло как? для десктоп-приложений мы писали, например, "new ClassPathXmlApplicationCotext..."
если с Томкатом и webXml, то у нас был ДиспетчерСервлет, который по каким-то конвенциям искал какой-то xml по умолчанию,Юи из него строил Контекст так и иначе.

А теперь у нас только SpringApplication.run()
Он может принимать на вход разные аргументы, например:
1. сапмкласс,вкотором он написан
2. String.class
3. "context.xml"
4. new ClassPathResource("context.xml")
5. Package.getPackage("com.example.boot.ripper")

ответ - можно заставить работать все варианты (и даже String.class, поплясав)
вдокументации написано, что передаем Имя класса, имя Пакета, расположение xml в виде массива Обжектов.

Когда мы сами создавали контекст в Мейне, у нас было много разных классов типа "#$%&ApplicationContext".

А наш спринг-Бутовый не заморачиваетсфя, и делвает только 2 вида контекстов: Web Context и Generic Context, и решает он очень просто: если в classpath есть javax.servlet.Servlet && ConfigurableWebApplicationContext, то делает Веб (AnnotationConfigEmbeddedWebApplicationContext). Иначе - делает AnnotationConfigAnnotationContext.

Передать "старые" типы контекстов мы все-таки можем, но все равно из них построится один из этих двух вариантов.
//таймкод 16:35


# Часть 3.2
И что там в этом контексте-то будет?
Мы не создали ни одного бина, унас только application.run(), на вход он получает тот же класс,помеченный @SpringBootApplication - что же там будет,если в этот контекст заглянуть? ответ, в нашем случае около 436 бинов. И это мы подключили всего пару стартеров. Микросервисная архитектура,блин! микросервис 180 мБ!

Откуда взялись все эти бины?
Магия этих стартеров втом, что...
вот мы подключили их 3 шт,иполучили поти 500. Подключили бы 10 - получилои быюбольше 1000. Потому что каждый стартер, кроме зависимостей, уже приносит какие-то конфигурации,вкоторых прописаны какие-то бины, во например:
Хотим например стартер для Веба. Погнали: DispatcherServlet, InternalResourceIOReolver...
Хотим starter-jpa - в нем EntityManagerFactoryBean и т.д.
Это всепрописано в их конфигурациях,и они приходят сами, без нашего участия.
Мы сегодлня сделаем точно также, то есть мы напишем стартер, который точно также будет приносить какие-то бины во все прилодения, которые этим стартером будут пользоваться.

# Часть 4. Пример
у Железного банка много разных приложений в разных филоиалах, но они хотят,чтобы каждый раз, когда поднимается приложение, посылался ворон с информацией о том, что приложение поднялось.

То есть, нам не надо писать код в приоложение конкретного банка, а мы будем писать стартер, чтобы все приложения Iron банка, которые используют этот стартер, посылали ворона при их поднятии.

Делаем новый Модуль iron-starter? структура каталогов src/java/main
Напишем новй класс,который будетпосылать ворона. Пусть это будет Listener, который слушает контекст,икогдаон рефрешнудся,значит надо посылать.
implements ApplicationListener<ContextRefreshedEvent>

Листенер это круто, но его неплохо все же прописать в какой-то конфигурации. Можно конечно @ComponentScan поставить, но для нашей задачи не подходит,т к это чужасконфигурация, конфигурация стартера. Сегоднядекларирует Листенер,завтра заказчик попросит что-нибудь другое, мы тожепропишем их в конфигурации этогшостартера.

Делаем класс IronConfiguration под аннотацией @Configuration
в нем @Bean RavenListener(){return new RavenListener();}

Вопрос, а как сделать,чтобы эта конфигурация автоматически подтянулась во все приложения? В СпрингБуте мы видели штуки типа @EnableSomeStarter на все случаи жизни. Допустим,мызависим от 20стартеров,и у нас стоят @EnableFirstStarter, @EnableSecondStarter и т.д. Как ёлка! давайте еще сделаем @import(SomeStarterConfig.class).. Нет! мы хотим сделать некую инверсию контроля, мы хотим подключая стартер иничего не знать о том, как называютсяего внутренности, но чтобы все работало.

Поэтому мыбудем использовать spring.factories. Что это такое?
В документации написано, что есть такой волшебный файл META-INF/spring.factories, в которм указано cответствие интерфейсов, и того, что надо по ним подгрузить (наши конфигурации). И после чего они волшебным образом появятся в нашем контексте.

Таким образом мы получаем инверсию контроля. То есть тот, кто подключил стартер, вместо того, чтобы обращаться к "кишкам" и выбирать, какую взять конфигурацию, все будет наоборот: У стартера будет файл,и в нем будет прописано,какая конфигурация дложна быть активизирована у всех тех, кто его подгрузил.

создаем resources/META-INF/spring.factories
в нем пишем

    org.springfrmework.boot.autoconfigure.EnableAutoConfiguration=com.ironbank.IronConfiguration

В какой-то момент СпрингБут начинает сканировать все jar'ы, и начинает искать вот этот файл spring.factories, мы это потом разберем подробнее, но пока подключим так.

теперь надо подключить, в Градле это выглядит как compile project(':iron-starter'), в Мавене надо поставить в депенденси.
Запускаем...Ворон полетел.
Причем мы для этого ничего не делали в нашем приложении.
С точки зрения пользователя мы просто подключили зависимость, и у нас появиласьконфигурацияи появился новый функцилонал.

Часть 5. Давайте теперь разберемся, как это работает.
//таймкод 23:40